# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['OPENAI_API_KEY', 'materials_gaf', 'employee', 'measurements', 'building_structure', 'property', 'property_owner',
           'SupportedTrade', 'RequiredRoofingMaterials', 'Material', 'RoofInputMeasurements', 'RoofingSettings',
           'MaterialTemplate', 'LineItem', 'MaterialList', 'RoofEstimate', 'TaxRules', 'EstimateStatus', 'Settings',
           'Employee', 'Estimate', 'BuildingStructure', 'OpportunityStage', 'Property', 'PropertyOwner',
           'get_materials_template', 'get_building_structure', 'get_property', 'get_property_owner',
           'get_property_owner_details', 'make_estimate_with_property', 'gradio_agent']

# %% ../nbs/00_core.ipynb 3
from langchain import (
    OpenAI,
)
from langchain.agents import initialize_agent, Tool
from langchain.agents import AgentType
from langchain.tools import BaseTool
from langchain.tools import tool, StructuredTool
from langchain.chat_models import ChatOpenAI
from langchain.prompts import MessagesPlaceholder
from langchain.memory import ConversationBufferMemory
import gradio as gr
import os

import modal

from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Union, Any, Tuple
from datetime import datetime, timedelta
import uuid
from enum import Enum

# %% ../nbs/00_core.ipynb 4
# This API key has been invalidated. Please use your own API key.
OPENAI_API_KEY = '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'
os.environ['OPENAI_API_KEY'] = OPENAI_API_KEY


# %% ../nbs/00_core.ipynb 6
class SupportedTrade(str, Enum):
    roofing = "roofing"

class RequiredRoofingMaterials(Enum):
    '''Materials required for ALL roofing jobs. Only supports full roof replacements for now.'''
    shingles = "shingles"
    underlayment = "underlayment"
    sheathing = "sheathing"
    nails = "nails"
    ridge_cap_shingles = "ridge_cap_shingles"
    valleys = "valleys"
    rakes = "rakes"
    eaves = "eaves"
    flashing = "flashing"
    step_flashing = "step_flashing"
    drip_edge = "drip_edge"

class Material(BaseModel):
    '''Material needed for a roofing job. Represents a single brand of shingle, underlayment, whatever.'''
    name: str
    role: RequiredRoofingMaterials = Field(..., description="Role of the material")
    quantity_per_package: float
    cost_per_unit: float
    waste_factor: float

class RoofInputMeasurements(BaseModel):
    '''Measurements of the roof. Represents the inputs to the roofing calculator.'''
    area_length: float = Field(..., description="Length of the area in feet")
    area_width: float = Field(..., description="Width of the area in feet")
    roof_area_total_length: float = Field(..., description="Total length of the roof area in feet")
    roof_facets: float = Field(..., description="Roof facets in square feet")
    ridges_hips: float = Field(..., description="Length of ridges/hips in feet")
    valleys: float = Field(..., description="Length of valleys in feet")
    rakes: float = Field(..., description="Length of rakes in feet")
    eaves: float = Field(..., description="Length of eaves in feet")
    flashing: float = Field(..., description="Length of flashing in feet")
    step_flashing: float = Field(..., description="Length of step flashing in feet")
    drip_edge_perimeter: float = Field(..., description="Length of drip edge/perimeter in feet")
    roof_pitch_percentage: float = Field(..., description="Roof pitch in percentage")

class RoofingSettings(BaseModel):
    '''Settings for a roofing job. Represents the assumptions for a roofing calculator. Set on a per-material-template basis.'''
    shingles_per_square: float = Field(..., description="Number of shingles per square")
    underlayment_per_square: float = Field(..., description="Number of underlayment per square")
    sheathing_per_square: float = Field(..., description="Number of sheathing per square")
    nails_per_square: float = Field(..., description="Number of nails per square")
    ridge_cap_shingles_per_linear_foot: float = Field(..., description="Number of ridge cap shingles per linear foot")

class MaterialTemplate(BaseModel):
    name: str
    materials: List[Material]
    settings: RoofingSettings

class LineItem(BaseModel):
    material: Material = Field(..., description="Material needed")
    package_count: float = Field(..., description="Number of packages needed")
    cost_per_package: float = Field(..., description="Cost per package")

class MaterialList(BaseModel):
    '''List of materials needed for a roofing job. Represents the output of the roofing calculator. Saved to the estimate'''
    Trade: SupportedTrade
    line_items: List[LineItem]

class RoofEstimate(BaseModel):
    '''Generate a list of materials for the a roofing job.'''
    required_roles: list = Field(RequiredRoofingMaterials, description="Role of the material")
    measurements: RoofInputMeasurements = Field(..., description="Measurements of the roof")
    material_templates: List[MaterialTemplate] = Field(..., description="Material templates for the roof")
    validated_templates: bool = Field(False, description="Whether the templates have been validated")

    def _validate_templates(self):
        for template in self.material_templates:
            for material in template.materials:
                if material.role.value not in list(self.required_roles.__members__):
                    raise ValueError(f"Invalid role {material.role} in material template {template.name}")
        self.validated_templates = True

    def _calculate_materials(self, material: Material, settings: RoofingSettings) -> Tuple[float, float]:
        '''Calculate the quantity and cost of a material.'''
        quantity = 0
        cost = 0
        match material.role:
            case self.required_roles.shingles:
                quantity = self.measurements.area_length * self.measurements.area_width / settings.shingles_per_square / material.quantity_per_package
                cost = quantity * material.cost_per_unit
                return quantity, cost

            case self.required_roles.underlayment:
                quantity = self.measurements.area_length * self.measurements.area_width / settings.underlayment_per_square / material.quantity_per_package
                cost = quantity * material.cost_per_unit
                return quantity, cost

            case self.required_roles.sheathing:
                quantity = self.measurements.area_length * self.measurements.area_width / settings.sheathing_per_square / material.quantity_per_package
                cost = quantity * material.cost_per_unit
                return quantity, cost

            case self.required_roles.nails:
                quantity = self.measurements.area_length * self.measurements.area_width / settings.nails_per_square / material.quantity_per_package
                cost = quantity * material.cost_per_unit
                return quantity, cost

            case self.required_roles.ridge_cap_shingles:
                quantity = self.measurements.ridges_hips / settings.ridge_cap_shingles_per_linear_foot / material.quantity_per_package
                cost = quantity * material.cost_per_unit
                return quantity, cost
            case _:
                # assuming 1 unit of material per linear foot for all other materials
                # not implementing rest of measurements for now
                return quantity, cost
                # quantity = getattr(self.measurements, material.role.value) / material.quantity_per_package
                # cost = quantity * material.cost_per_unit

    def estimate(self) -> Union[MaterialList, List[MaterialList]]:
        '''Estimate the materials needed for a roofing job. Returns a list of material lists if there are multiple material templates.'''
        if not self.validated_templates:
            self._validate_templates()
            
        line_items = []
        if len(self.material_templates) == 1:
            template = self.material_templates[0]
            settings = template.settings
            for material in template.materials:
                quantity, cost = self._calculate_materials(material, settings)
                line_items.append(LineItem(material=material, package_count=quantity, cost_per_package=cost))
            return MaterialList(Trade=SupportedTrade.roofing, line_items=line_items)
        else:
            material_lists = []
            for template in self.material_templates:
                settings = template.settings
                line_items = []
                for material in template.materials:
                    quantity, cost = self._calculate_materials(material, settings)
                    line_items.append(LineItem(material=material, package_count=quantity, cost_per_package=cost))
                material_lists.append(MaterialList(Trade=SupportedTrade.roofing, line_items=line_items))
            return material_lists


# %% ../nbs/00_core.ipynb 9
class TaxRules(BaseModel):
    '''Tax rules for a location. Represents the tax rules for a location. Set on a per-location basis.'''
    location: str
    rate: float

class EstimateStatus(str, Enum):
    '''Status of an estimate. Represents the status of an estimate. Set on a per-estimate basis.'''
    DRAFT = "draft"
    DELIVERED = "delivered"
    REVIEWED = "reviewed"

class Settings(BaseModel):
    '''Settings for an estimate. Represents the assumptions for an estimate. Set on a per-estimate basis.'''
    universal_profit_margin: float
    default_valid_until_days: int

class Employee(BaseModel):
    '''Employee information. Represents the information of an employee. Set on a per-employee basis.'''
    name: str
    role: str
    email: str

class Estimate(BaseModel):
    '''Estimate for a job. Represents the output of the estimate calculator. Saved to the property.'''
    id: str
    version: int
    trades: SupportedTrade
    material_lists: List[MaterialList]
    additional_costs: Dict[str, float]  # Additional costs as key-value pairs
    labor_items: Dict[str, float]  # Labor items as key-value pairs
    total_cost: float = Field(..., description="Total cost of the estimate")
    status: EstimateStatus
    valid_until: Optional[datetime]
    tax: TaxRules
    primary_contact: Employee
    estimator: Employee

class BuildingStructure(BaseModel):
    '''Building structure. Represents a building structure. Saved to the property.'''
    id: str
    name: str
    roof_measurements: RoofInputMeasurements
    estimates: Optional[Union[List[Estimate], Estimate]]

class OpportunityStage(Enum):
    '''Opportunity stage. Represents the stage of an opportunity. Saved to the property.'''
    LEAD = "lead"
    ESTIMATE = "estimate"
    CONTRACT = "contract"
    JOB = "job"

class Property(BaseModel):
    '''Property. Represents a property. Saved to the property owner.'''
    id: str
    opportunity_stage: OpportunityStage
    name: str
    structures: List[BuildingStructure]

class PropertyOwner(BaseModel):
    '''Property owner. Represents a property owner. Saved to the opportunity.'''
    id: str
    name: str
    properties: List[Property]

# %% ../nbs/00_core.ipynb 11
#commented out materials means I didn't implement the calculations for them yet
materials_gaf = {
    "materials": [
        {
            "name": "Timberline HD Shingles",
            "brand": "GAF",
            "role": "shingles",
            "quantity_per_package": 21,
            "cost_per_unit": 30,
            "waste_factor": 0.15
        },
        # {
        #     "name": "Pro-Start Eave/Rake Starter Strip",
        #     "brand": "GAF",
        #     "role": "starter_strip",
        #     "quantity_per_package": 100,
        #     "cost_per_unit": 1.5,
        #     "waste_factor": 0.05
        # },
        {
            "name": "Tiger Paw Roof Deck Protection",
            "brand": "GAF",
            "role": "underlayment",
            "quantity_per_package": 10,
            "cost_per_unit": 60,
            "waste_factor": 0.1
        },
        {
            "name": "DuraGrip Nails",
            "brand": "GAF",
            "role": "nails",
            "quantity_per_package": 2000,
            "cost_per_unit": 0.05,
            "waste_factor": 0.2
        },
        {
            "name": "TimberTex Premium Ridge Cap Shingles",
            "brand": "GAF",
            "role": "ridge_cap_shingles",
            "quantity_per_package": 20,
            "cost_per_unit": 35,
            "waste_factor": 0.1
        },
        # {
        #     "name": "WeatherBlocker Premium Eave/Rake Starter Strip",
        #     "brand": "GAF",
        #     "role": "starter_strip",
        #     "quantity_per_package": 100,
        #     "cost_per_unit": 2,
        #     "waste_factor": 0.05
        # },
        {
            "name": "WeatherBlocker Premium Eave/Rake Edge Flashing",
            "brand": "GAF",
            "role": "flashing",
            "quantity_per_package": 10,
            "cost_per_unit": 15,
            "waste_factor": 0.1
        },
        {
            "name": "TimberTex Premium Ridge Cap Shingles",
            "brand": "GAF",
            "role": "ridge_cap_shingles",
            "quantity_per_package": 20,
            "cost_per_unit": 35,
            "waste_factor": 0.1
        },
        # {
        #     "name": "Seal-A-Ridge Hip & Ridge Shingles",
        #     "brand": "GAF",
        #     "role": "hip_ridge_shingles",
        #     "quantity_per_package": 12,
        #     "cost_per_unit": 25,
        #     "waste_factor": 0.1
        # },
        {
            "name": "WeatherBlocker Premium Step Flashing",
            "brand": "GAF",
            "role": "step_flashing",
            "quantity_per_package": 10,
            "cost_per_unit": 20,
            "waste_factor": 0.1
        },
        {
            "name": "WeatherBlocker Premium Drip Edge",
            "brand": "GAF",
            "role": "drip_edge",
            "quantity_per_package": 10,
            "cost_per_unit": 15,
            "waste_factor": 0.1
        }
    ]
}

employee = {
    "name": "Doug Doe",
    "role": "Sales",
    "email": "none"
}

measurements = RoofInputMeasurements(area_length=100, area_width=200, roof_area_total_length=300, roof_facets=400, ridges_hips=500, valleys=600, rakes=700, eaves=800, flashing=900, step_flashing=1000, drip_edge_perimeter=1100, roof_pitch_percentage=1200)

building_structure = {
    "id": "123",
    "name": "Residential House",
    "roof_measurements": measurements,
    "estimates": []
}

property = {
    "id": "123",
    "opportunity_stage": "lead",
    "name": "123 Main Street",
    "structures": [
        building_structure
    ]
}

property_owner = {
    "id": "123",
    "name": "John Doe",
    "properties": [property]
}

@tool
def get_materials_template(template_name: str):
    '''Get the materials template from the database.'''
    settings = RoofingSettings(shingles_per_square=100, underlayment_per_square=200, sheathing_per_square=300, nails_per_square=400, ridge_cap_shingles_per_linear_foot=500)
    material_template = MaterialTemplate(name="GAF Template", materials=materials_gaf["materials"], settings=settings)
    return material_template

@tool
def get_building_structure(building_id: str):
    '''Get the building structure from the database.'''
    return BuildingStructure(id=building_structure["id"], name=building_structure['name'], roof_measurements=building_structure['roof_measurements'], estimates=building_structure['estimates'])

@tool
def get_property(property_id: str):
    '''Get the property from the database.'''
    return Property(id=property['id'], opportunity_stage=property['opportunity_stage'], name=property['name'], structures=property['structures'])

@tool
def get_property_owner(owner_id: str):
    '''Get the property owner from the database.'''
    return PropertyOwner(id=property_owner['id'], name=property_owner['name'], properties=property_owner['properties'])

@tool
def get_property_owner_details(name: str):
    '''Get the property owner details from the database.
    Returns the property owner name and properties ids along with opportunity stage in a human readable format.'''
    property_owner = get_property_owner(name).model_dump()
    properties = ''
    structures = 0
    for property in property_owner['properties']:
        for structure in property['structures']:
            structures += 1
        properties += f"{property['name']} opportunity stage:({property['opportunity_stage']} id:({property['id']}))"
    details = f"""Property owner: {property_owner['name']}
    Properties: {properties}
    Structures: {structures}
    """
    return details


def make_estimate_with_property(id: str, material_list_name: str):
    '''Create an estimate with a property.'''
    material_template = get_materials_template(material_list_name)
    estimator = Employee(**employee)
    primary_contact = Employee(**employee)
    roof_estimate = RoofEstimate(measurements=measurements, material_templates=[material_template])
    material_list = roof_estimate.estimate()
    estimate = Estimate(id=str(uuid.uuid4()), version=1, trades=SupportedTrade.roofing, material_lists=[material_list], additional_costs={}, labor_items={}, total_cost=0, status=EstimateStatus.DRAFT, valid_until=datetime.now() + timedelta(days=30), tax=TaxRules(location="CA", rate=0.1), primary_contact=primary_contact, estimator=estimator)
    return estimate

# %% ../nbs/00_core.ipynb 18
def gradio_agent(msg, history):
    tools = [StructuredTool.from_function(make_estimate_with_property), get_property_owner_details, get_property_owner, get_property, get_building_structure, get_materials_template]
    agent_kwargs = {
        "extra_prompt_messages": [MessagesPlaceholder(variable_name="memory")],
    }
    llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo-0613")
    memory = ConversationBufferMemory(memory_key="memory", return_messages=True)
    agent = initialize_agent(
        tools,
        llm,
        agent=AgentType.OPENAI_FUNCTIONS,
        verbose=True,
        agent_kwargs=agent_kwargs,
        memory=memory,
    )
    return agent.run(msg)
